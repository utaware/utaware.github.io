import{g as u,o as s,c as r,F as f,h as T,b as t,t as c,n as b,e,u as a,a as g,d as l}from"./app-qSMjXEym.js";import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";const m={class:"rail-standard-list"},I={class:"content"},x={class:"tip"},F=u({__name:"WebRailRange",props:{tips:{},unit:{default:""}},setup(_){const d=[{text:"GOOD",type:"success"},{text:"NEEDS IMPROVEMENT",type:"warning"},{text:"POOR",type:"danger"}];return(n,W)=>(s(),r("ul",m,[(s(),r(f,null,T(d,(o,h)=>t("li",{class:"rail-standard-list-item",style:b({backgroundColor:`var(--color-${o.type})`}),key:h},[t("span",I,c(o.text),1),t("span",x,c(n.tips[h]+n.unit),1)],4)),64))]))}}),i=p(F,[["__scopeId","data-v-b9c8b7d5"],["__file","WebRailRange.vue"]]),C=g('<h1 id="rail模型" tabindex="-1"><a class="header-anchor" href="#rail模型" aria-hidden="true">#</a> RAIL模型</h1><p><a href="">RAIL</a>是一种以用户为中心的性能模型，将用户体验分解到按钮操作（比如：点击、滚动、加载）中，为每个操作定义性能目标</p><p>RAIL代表Web应用生命周期的四个不同方面：响应、动画、空闲、加载</p><h2 id="响应-response" tabindex="-1"><a class="header-anchor" href="#响应-response" aria-hidden="true">#</a> 响应(Response)</h2><p><strong>目标:</strong></p><ul><li>在100毫秒内完成由用户输入发起的转换，让用户感觉交互是即时的。</li></ul><p><strong>准则:</strong></p><ul><li>为了确保在 100 毫秒内产生可见响应，需要在 50 毫秒内处理用户输入事件。这适用于大多数输入，例如点击按钮、切换表单控件或启动动画。但是，这不适用于触摸拖动或滚动。</li><li>尽管听起来可能有些自相矛盾，但是，即时响应用户输入并非总是正确的做法。您可以利用这100毫秒的时间窗口来执行其他需要消耗大量资源的工作，但是，注意不能妨碍用户。如果可能，应在后台工作。</li><li>对于需要 50 毫秒以上才能完成的操作，请随时提供反馈。</li></ul><blockquote><p>目标是在 100 毫秒内响应输入，那么，为什么我们的预算只有 50 毫秒？这是因为除输入处理外，通常还有需要执行其他工作，而且这些工作会占用可接受输入响应的部分可用时间。如果应用程序在空闲时间以推荐的 50 毫秒区块执行工作，这就意味着，如果输入在这些工作区块之一中发生，它最多可能会排队 50 毫秒。考虑到这一点，假设只有剩余的 50 毫秒可用于实际输入处理才是安全地做法。</p></blockquote><h2 id="动画-animation" tabindex="-1"><a class="header-anchor" href="#动画-animation" aria-hidden="true">#</a> 动画(Animation)</h2><p><strong>目标:</strong></p><ul><li>在 10 毫秒或更短的时间内生成动画的每一帧。从技术上来讲，每帧的最大预算为16毫秒（1000毫秒/每秒60帧≈16毫秒），但是，浏览器需要大约6毫秒来渲染一帧，因此，准则为每帧10毫秒。</li><li>目标为流畅的视觉效果。用户会注意到帧速率的变化。</li></ul><p><strong>准则:</strong></p><ul><li>在动画之类对计算速度要求极高的场景下，关键在于即使可行，您也不能执行任何其他操作，让不能执行的操作保持绝对最少。只要可能，您就要利用这 100 毫秒的响应时间预先计算最消耗资源的工作，从而最大限度地提高达到 60 fps 的几率。</li></ul><h2 id="空闲-idle" tabindex="-1"><a class="header-anchor" href="#空闲-idle" aria-hidden="true">#</a> 空闲(Idle)</h2><p><strong>目标:</strong></p><ul><li>最大限度增加空闲时间以提高页面在 50 毫秒内响应用户输入的几率。</li></ul><p><strong>准则:</strong></p><ul><li>利用空闲时间完成延缓的工作。例如，对于初始页面加载，应加载尽可能少的数据，然后利用空闲时间加载其余数据。</li><li>在 50 毫秒或更短的空闲时间内执行工作。如果时间更长，您可能会干扰应用在 50 毫秒内响应用户输入的能力。</li><li>如果用户在空闲时间工作期间与页面交互，则应中断空闲时间工作，用户交互始终具有最高优先级。</li></ul><h2 id="加载-load" tabindex="-1"><a class="header-anchor" href="#加载-load" aria-hidden="true">#</a> 加载(Load)</h2><blockquote><p>当页面加载缓慢时，用户注意力会分散，会认为任务已中断。</p></blockquote><p><strong>目标:</strong></p><ul><li>根据用户的设备和网络能力优化相关的快速加载性能。目前，对于首次加载，在使用速度较慢 3G 连接的中端移动设备上，理想的目标是在5秒或更短的时间内实现可交互。</li><li>对于后续加载，理想的目标是在2秒内加载页面。</li></ul><p><strong>准则:</strong></p><ul><li>为了产生完整加载的感觉，不必在5秒钟时间内加载所有内容。不妨考虑延迟加载图像、代码拆分JavaScript包以及web.dev上建议的其他优化。</li></ul><h2 id="性能延迟指标" tabindex="-1"><a class="header-anchor" href="#性能延迟指标" aria-hidden="true">#</a> 性能延迟指标</h2><table><thead><tr><th>延迟</th><th>用户反应</th></tr></thead><tbody><tr><td>0 - 16 毫秒</td><td>人们特别擅长跟踪运动，如果动画不流畅，他们就会对运动心生反感。 用户可以感知每秒渲染 60 帧的平滑动画转场。也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），留给应用大约 10 毫秒的时间来生成一帧。</td></tr><tr><td>0 - 100 毫秒</td><td>在此时间窗口内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。</td></tr><tr><td>100 - 300 毫秒</td><td>用户会遇到轻微可觉察的延迟。</td></tr><tr><td>300 - 1000 毫秒</td><td>在此窗口内，延迟感觉像是任务自然和持续发展的一部分。对于网络上的大多数用户，加载页面或更改视图代表着一个任务。</td></tr><tr><td>1000+ 毫秒</td><td>超过 1 秒，用户的注意力将离开他们正在执行的任务。</td></tr><tr><td>10,000+ 毫秒</td><td>用户感到失望，可能会放弃任务；之后他们或许不会再回来。</td></tr></tbody></table><h3 id="fp-fcp" tabindex="-1"><a class="header-anchor" href="#fp-fcp" aria-hidden="true">#</a> FP&amp;FCP</h3><ul><li>FP：首次绘制，FP（First Paint），当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</li><li>FCP：首次内容绘制，FCP（First Contentful Paint）：这个指标用于记录页面首次绘制文本、图片、非空白Canvas或SVG的时间。</li></ul>',29),P=t("h3",{id:"lcp",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#lcp","aria-hidden":"true"},"#"),l(" LCP")],-1),D=t("p",null,"最大绘制内容，LCP（Largest Contentful Paint），用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生变化。另外该指标会在用户第一次交互后停止记录。",-1),v=t("h3",{id:"tti",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#tti","aria-hidden":"true"},"#"),l(" TTI")],-1),y=t("p",null,"TTI（Time to Interactive）是衡量一个页面完成变成可交互状态的时间，当一个页面满足以下几个条件时可以认为该页面是完全可交互的：",-1),L=t("ul",null,[t("li",null,"从FCP指标后开始计算，保证已经有内容被渲染出来。"),t("li",null,"大多数的事件已经挂载在DOM上，完成注册。"),t("li",null,"此时主线程已经达到“流畅”的程度，主线程的任务均不超过 50 毫秒。")],-1),R=t("h3",{id:"fid",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#fid","aria-hidden":"true"},"#"),l(" FID")],-1),k=t("p",null,"FID（First Input Delay）译为首次输入延迟。顾名思义，FID指的是用户首次与产品进行交互时，产品可以在多长时间给出反馈。",-1),S=t("blockquote",null,[t("p",null,"TTI可以告诉我们网页什么时候可以开始流畅地响应用户的交互，但是如果用户在TTI的时间内，没有与网页产生交互，那么TTI其实是影响不到用户的，TTI是不需要用户参与的指标，但如果我们真的想知道TTI对用户的影响，我们需要FID。不同的用户可能会在TTI之前开始与网页产生交互，也可能在TTI之后才与网页产生交互。所以对于不同的用户它的FID是不同的。如果在TTI之前用户就已经与网页产生了交互，那么它的FID时间就比较长，而如果在TTI之后才第一次与网页产生交互，那么他的FID时间就短。")],-1),B=t("h3",{id:"tbt",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#tbt","aria-hidden":"true"},"#"),l(" TBT")],-1),N=t("p",null,"阻塞总时间，TBT（Total Blocking Time）汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task中阻塞部分都会被汇总。",-1),O=t("h3",{id:"cls",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#cls","aria-hidden":"true"},"#"),l(" CLS")],-1),V=t("p",null,"累计位移偏量,CLS（Cumulative Layout Shift），记录了页面上非预期的位移波动。计算方式为：位移影响的面积 * 位移距离。",-1),q=t("h2",{id:"如何获取指标",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#如何获取指标","aria-hidden":"true"},"#"),l(" 如何获取指标")],-1),E=t("ul",null,[t("li",null,"Chrome DevTools - Lighthouse"),t("li",null,"Chrome DevTools - Performance"),t("li",null,"web-vitals 库")],-1),A=u({__name:"index.html",setup(_){return(d,n)=>(s(),r("div",null,[C,e(a(i),{tips:[0,1.8,3],unit:"s"}),P,D,e(a(i),{tips:[0,2.5,4],unit:"s"}),v,y,L,e(a(i),{tips:[0,3.8,7.3],unit:"s"}),R,k,S,e(a(i),{tips:[0,100,300],unit:"ms"}),B,N,e(a(i),{tips:[0,200,600],unit:"ms"}),O,V,e(a(i),{tips:[0,.1,.25]}),q,E]))}}),M=p(A,[["__file","index.html.vue"]]);export{M as default};
