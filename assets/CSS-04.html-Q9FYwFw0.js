import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,a}from"./app-qSMjXEym.js";const e={},l=a(`<h1 id="重排-reflow-和重绘-repaint" tabindex="-1"><a class="header-anchor" href="#重排-reflow-和重绘-repaint" aria-hidden="true">#</a> 重排(reflow)和重绘(repaint)</h1><ul><li>Rendering ：渲染</li><li>Repaint：重绘</li><li>Reflow: 回流（也称重排）</li><li>Relayout：重新布局 （和 Reflow 表达相同的意思）</li><li>Restyle ：重新设计（重写样式）</li></ul><h2 id="重排" tabindex="-1"><a class="header-anchor" href="#重排" aria-hidden="true">#</a> 重排</h2><blockquote><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">提示</p><p>在回答什么是重排的时候，关键不是位置发生变动，这只是原因(Why)，而不是 What。What 是重新计算每个元素在设备视口内的确切位置和大小。</p></div><p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p><ul><li>页面初始渲染，这是开销最大的一次重排</li><li>添加/删除可见的DOM元素</li><li>改变元素位置</li><li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li><li>改变元素内容，比如文字数量，图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，比如resize事件发生时</li><li>激活CSS伪类（例如：<code>:hover</code>）</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h3><table><thead><tr><th>常见引起重排属性和方法</th><th style="text-align:center;">-</th><th style="text-align:right;">-</th><th style="text-align:right;">-</th></tr></thead><tbody><tr><td>width</td><td style="text-align:center;">height</td><td style="text-align:right;">margin</td><td style="text-align:right;">padding</td></tr><tr><td>display</td><td style="text-align:center;">border-width</td><td style="text-align:right;">border</td><td style="text-align:right;">position</td></tr><tr><td>overflow</td><td style="text-align:center;">font-size</td><td style="text-align:right;">vertical-align</td><td style="text-align:right;">min-height</td></tr><tr><td>clientWidth</td><td style="text-align:center;">clientHeight</td><td style="text-align:right;">clientTop</td><td style="text-align:right;">clientLeft</td></tr><tr><td>offsetWidth</td><td style="text-align:center;">offsetHeight</td><td style="text-align:right;">offsetTop</td><td style="text-align:right;">offsetLeft</td></tr><tr><td>scrollWidth</td><td style="text-align:center;">scrollHeight</td><td style="text-align:right;">scrollTop</td><td style="text-align:right;">scrollLeft</td></tr><tr><td>scrollIntoView()</td><td style="text-align:center;">scrollTo()</td><td style="text-align:right;">getComputedStyle()</td><td style="text-align:right;"></td></tr><tr><td>getBoundingClientRect()</td><td style="text-align:center;">scrollIntoViewIfNeeded()</td><td style="text-align:right;"></td><td style="text-align:right;"></td></tr></tbody></table><h2 id="重绘-repaints" tabindex="-1"><a class="header-anchor" href="#重绘-repaints" aria-hidden="true">#</a> 重绘(Repaints)</h2><blockquote><p>元素的 样式发生变动 ，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">提示</p><p>而回答什么是重绘的关键点在于在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这才是 What。</p></div><h3 id="属性-1" tabindex="-1"><a class="header-anchor" href="#属性-1" aria-hidden="true">#</a> 属性</h3><table><thead><tr><th>属性：</th><th style="text-align:center;">-</th><th style="text-align:right;">-</th><th style="text-align:right;">-</th></tr></thead><tbody><tr><td>color</td><td style="text-align:center;">border-style</td><td style="text-align:right;">visibility</td><td style="text-align:right;">background</td></tr><tr><td>text-decoration</td><td style="text-align:center;">background-image</td><td style="text-align:right;">background-position</td><td style="text-align:right;">background-repeat</td></tr><tr><td>outline-color</td><td style="text-align:center;">outline</td><td style="text-align:right;">outline-style</td><td style="text-align:right;">border-radius</td></tr><tr><td>outline-width</td><td style="text-align:center;">box-shadow</td><td style="text-align:right;">background-size</td><td style="text-align:right;"></td></tr></tbody></table><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2><ul><li>样式集中改变</li></ul><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 cssText 变量中编辑。虽然现在大部分现代浏览器都会有 Flush 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// bad</span>
<span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token string">&quot;px&quot;</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token string">&quot;px&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 当top和left的值是动态计算而成时...</span>
<span class="token comment">// better </span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+=</span> <span class="token string">&quot;; left: &quot;</span> <span class="token operator">+</span> left <span class="token operator">+</span> <span class="token string">&quot;px; top: &quot;</span> <span class="token operator">+</span> top <span class="token operator">+</span> <span class="token string">&quot;px;&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// better</span>
el<span class="token punctuation">.</span>className <span class="token operator">+=</span> <span class="token string">&quot; className&quot;</span><span class="token punctuation">;</span>

复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>分离读写操作</li></ul><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// bad 强制刷新 触发四次重排+重绘</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>right <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetRight <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>bottom <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetBottom <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>


<span class="token comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span>
<span class="token keyword">var</span> curLeft <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>
<span class="token keyword">var</span> curTop <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>
<span class="token keyword">var</span> curRight <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetRight<span class="token punctuation">;</span>
<span class="token keyword">var</span> curBottom <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetBottom<span class="token punctuation">;</span>

div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> curLeft <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> curTop <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>right <span class="token operator">=</span> curRight <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>bottom <span class="token operator">=</span> curBottom <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;px&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>将 DOM 离线 操作完成后再添加到文档中</p><ul><li>使用 display:none</li><li>documentFragment 创建 dom 碎片</li><li>absolute 或 fixed 脱离文档流</li></ul></li><li><p>优化动画</p></li></ul><p>在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。</p><h2 id="关键渲染路径" tabindex="-1"><a class="header-anchor" href="#关键渲染路径" aria-hidden="true">#</a> 关键渲染路径</h2><p>关键渲染路径(Critical Rendering Path)是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。</p><ol><li>HTML 被 HTML 解析器解析成 DOM 树</li><li>CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><blockquote><p>优化关键渲染路径可以缩短首次渲染的时间。了解和优化关键渲染路径对于确保重排和重绘可以每秒 60 帧的速度进行，以确保高效的用户交互并避免讨厌是很重要的。</p></blockquote><h3 id="_1-生成-dom" tabindex="-1"><a class="header-anchor" href="#_1-生成-dom" aria-hidden="true">#</a> 1. 生成 DOM</h3><p>DOM 构建是增量的。</p><ol><li>Bytes: 浏览器从获取数据 <code>3C 62 6F...</code></li><li>Characters: 根据相应的编码 (utf8) 转化为字符串 <code>&lt;html&gt;&lt;head&gt;...&lt;/hed&gt;&lt;/html&gt;</code></li><li>Tokens: 通过 AST 解析为 Token <code>startTag: html, startTag: head, ...</code></li><li>Nodes: 生成对应dom节点 <code>documentElement</code></li><li>DOM: 构建生成dom树</li></ol><h3 id="_2-生成-cssom" tabindex="-1"><a class="header-anchor" href="#_2-生成-cssom" aria-hidden="true">#</a> 2. 生成 CSSOM</h3><p>浏览器解析 css 文件，生成 CSSOM。CSSOM 包含了页面所有的样式，也就是如何展示 DOM 的信息。</p><p>DOM 构造是增量的，CSSOM 却不是。CSS 是渲染阻塞的：浏览器会阻塞页面渲染直到它接收和执行了所有的 CSS。</p><p>CSS 是渲染阻塞是因为规则可以被覆盖，所以内容不能被渲染直到 CSSOM 的完成。</p><h3 id="_3-render-tree" tabindex="-1"><a class="header-anchor" href="#_3-render-tree" aria-hidden="true">#</a> 3. Render Tree</h3><p>渲染树(Render Tree)包括了内容和样式：DOM 和 CSSOM 树结合为渲染树。</p><p>为了构造渲染树，浏览器检查每个节点，从 DOM 树的根节点开始，并且决定哪些 CSS 规则被添加。</p><p>渲染树只包含了可见内容（body 里的部分）。</p><p>Head（通常）不包含任何可见信息，因此不会被包含在渲染树种。如果有元素上有 display: none;，它本身和其后代都不会出现在渲染树中。</p><h3 id="_4-layout" tabindex="-1"><a class="header-anchor" href="#_4-layout" aria-hidden="true">#</a> 4. Layout</h3><p>一旦渲染树被构建，布局变成了可能。布局取决于屏幕的尺寸。布局这个步骤决定了在哪里和如何在页面上放置元素，决定了每个元素的宽和高，以及他们之间的相关性。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><blockquote><p>一个页面渲染在不同尺寸的屏幕上，比如渲染在移动端和 PC 端上，展示有差异，在前面的步骤都是不变的，只有在布局的时候才会根据屏幕尺寸进行差异化处理。</p></blockquote></div><h3 id="_5-paint" tabindex="-1"><a class="header-anchor" href="#_5-paint" aria-hidden="true">#</a> 5. Paint</h3><p>最后一步是将像素绘制在屏幕上，栅格化所有元素，将元素转换为实际像素。</p><p>一旦渲染树创建并且布局完成，像素就可以被绘制在屏幕上。加载时，整个屏幕被绘制出来。之后，只有受影响的屏幕区域会被重绘，浏览器被优化为只重绘需要绘制的最小区域。</p><blockquote><p>绘制时间取决于何种类型的更新被附加在渲染树上。绘制是一个非常快的过程，所以聚焦在提升性能时这大概不是最有效的部分</p></blockquote>`,46),i=[l];function o(p,r){return n(),s("div",null,i)}const u=t(e,[["render",o],["__file","CSS-04.html.vue"]]);export{u as default};
