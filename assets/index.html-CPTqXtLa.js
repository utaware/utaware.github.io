import{f as h,c as i,o as s,F as m,g as c,b as t,t as u,n as g,a as b,d as a,u as n}from"./app-DywCN-wo.js";import{_ as T}from"./plugin-vue_export-helper-DlAUqK2U.js";const f={class:"rail-standard-list"},I={class:"content"},y={class:"tip"},R=h({__name:"WebRailRange",props:{tips:{},unit:{default:""}},setup(r){const o=[{text:"GOOD",type:"success"},{text:"NEEDS IMPROVEMENT",type:"warning"},{text:"POOR",type:"danger"}];return(e,L)=>(s(),i("ul",f,[(s(),i(m,null,c(o,(p,d)=>t("li",{class:"rail-standard-list-item",style:g({backgroundColor:`var(--color-${p.type})`}),key:d},[t("span",I,u(p.text),1),t("span",y,u(r.tips[d]+r.unit),1)],4)),64))]))}}),l=T(R,[["__scopeId","data-v-a4b2ccad"]]),P=h({__name:"index.html",setup(r){return(o,e)=>(s(),i("div",null,[e[0]||(e[0]=b('<h1 id="rail模型" tabindex="-1"><a class="header-anchor" href="#rail模型"><span>RAIL模型</span></a></h1><p><a href="">RAIL</a>是一种以用户为中心的性能模型，将用户体验分解到按钮操作（比如：点击、滚动、加载）中，为每个操作定义性能目标</p><p>RAIL代表Web应用生命周期的四个不同方面：响应、动画、空闲、加载</p><h2 id="响应-response" tabindex="-1"><a class="header-anchor" href="#响应-response"><span>响应(Response)</span></a></h2><p><strong>目标:</strong></p><ul><li>在100毫秒内完成由用户输入发起的转换，让用户感觉交互是即时的。</li></ul><p><strong>准则:</strong></p><ul><li>为了确保在 100 毫秒内产生可见响应，需要在 50 毫秒内处理用户输入事件。这适用于大多数输入，例如点击按钮、切换表单控件或启动动画。但是，这不适用于触摸拖动或滚动。</li><li>尽管听起来可能有些自相矛盾，但是，即时响应用户输入并非总是正确的做法。您可以利用这100毫秒的时间窗口来执行其他需要消耗大量资源的工作，但是，注意不能妨碍用户。如果可能，应在后台工作。</li><li>对于需要 50 毫秒以上才能完成的操作，请随时提供反馈。</li></ul><blockquote><p>目标是在 100 毫秒内响应输入，那么，为什么我们的预算只有 50 毫秒？这是因为除输入处理外，通常还有需要执行其他工作，而且这些工作会占用可接受输入响应的部分可用时间。如果应用程序在空闲时间以推荐的 50 毫秒区块执行工作，这就意味着，如果输入在这些工作区块之一中发生，它最多可能会排队 50 毫秒。考虑到这一点，假设只有剩余的 50 毫秒可用于实际输入处理才是安全地做法。</p></blockquote><h2 id="动画-animation" tabindex="-1"><a class="header-anchor" href="#动画-animation"><span>动画(Animation)</span></a></h2><p><strong>目标:</strong></p><ul><li>在 10 毫秒或更短的时间内生成动画的每一帧。从技术上来讲，每帧的最大预算为16毫秒（1000毫秒/每秒60帧≈16毫秒），但是，浏览器需要大约6毫秒来渲染一帧，因此，准则为每帧10毫秒。</li><li>目标为流畅的视觉效果。用户会注意到帧速率的变化。</li></ul><p><strong>准则:</strong></p><ul><li>在动画之类对计算速度要求极高的场景下，关键在于即使可行，您也不能执行任何其他操作，让不能执行的操作保持绝对最少。只要可能，您就要利用这 100 毫秒的响应时间预先计算最消耗资源的工作，从而最大限度地提高达到 60 fps 的几率。</li></ul><h2 id="空闲-idle" tabindex="-1"><a class="header-anchor" href="#空闲-idle"><span>空闲(Idle)</span></a></h2><p><strong>目标:</strong></p><ul><li>最大限度增加空闲时间以提高页面在 50 毫秒内响应用户输入的几率。</li></ul><p><strong>准则:</strong></p><ul><li>利用空闲时间完成延缓的工作。例如，对于初始页面加载，应加载尽可能少的数据，然后利用空闲时间加载其余数据。</li><li>在 50 毫秒或更短的空闲时间内执行工作。如果时间更长，您可能会干扰应用在 50 毫秒内响应用户输入的能力。</li><li>如果用户在空闲时间工作期间与页面交互，则应中断空闲时间工作，用户交互始终具有最高优先级。</li></ul><h2 id="加载-load" tabindex="-1"><a class="header-anchor" href="#加载-load"><span>加载(Load)</span></a></h2><blockquote><p>当页面加载缓慢时，用户注意力会分散，会认为任务已中断。</p></blockquote><p><strong>目标:</strong></p><ul><li>根据用户的设备和网络能力优化相关的快速加载性能。目前，对于首次加载，在使用速度较慢 3G 连接的中端移动设备上，理想的目标是在5秒或更短的时间内实现可交互。</li><li>对于后续加载，理想的目标是在2秒内加载页面。</li></ul><p><strong>准则:</strong></p><ul><li>为了产生完整加载的感觉，不必在5秒钟时间内加载所有内容。不妨考虑延迟加载图像、代码拆分JavaScript包以及web.dev上建议的其他优化。</li></ul><h2 id="性能延迟指标" tabindex="-1"><a class="header-anchor" href="#性能延迟指标"><span>性能延迟指标</span></a></h2><table><thead><tr><th>延迟</th><th>用户反应</th></tr></thead><tbody><tr><td>0 - 16 毫秒</td><td>人们特别擅长跟踪运动，如果动画不流畅，他们就会对运动心生反感。 用户可以感知每秒渲染 60 帧的平滑动画转场。也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），留给应用大约 10 毫秒的时间来生成一帧。</td></tr><tr><td>0 - 100 毫秒</td><td>在此时间窗口内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。</td></tr><tr><td>100 - 300 毫秒</td><td>用户会遇到轻微可觉察的延迟。</td></tr><tr><td>300 - 1000 毫秒</td><td>在此窗口内，延迟感觉像是任务自然和持续发展的一部分。对于网络上的大多数用户，加载页面或更改视图代表着一个任务。</td></tr><tr><td>1000+ 毫秒</td><td>超过 1 秒，用户的注意力将离开他们正在执行的任务。</td></tr><tr><td>10,000+ 毫秒</td><td>用户感到失望，可能会放弃任务；之后他们或许不会再回来。</td></tr></tbody></table><h3 id="fp-fcp" tabindex="-1"><a class="header-anchor" href="#fp-fcp"><span>FP&amp;FCP</span></a></h3><ul><li>FP：首次绘制，FP（First Paint），当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</li><li>FCP：首次内容绘制，FCP（First Contentful Paint）：这个指标用于记录页面首次绘制文本、图片、非空白Canvas或SVG的时间。</li></ul>',29)),a(n(l),{tips:[0,1.8,3],unit:"s"}),e[1]||(e[1]=t("h3",{id:"lcp",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#lcp"},[t("span",null,"LCP")])],-1)),e[2]||(e[2]=t("p",null,"最大绘制内容，LCP（Largest Contentful Paint），用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生变化。另外该指标会在用户第一次交互后停止记录。",-1)),a(n(l),{tips:[0,2.5,4],unit:"s"}),e[3]||(e[3]=t("h3",{id:"tti",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#tti"},[t("span",null,"TTI")])],-1)),e[4]||(e[4]=t("p",null,"TTI（Time to Interactive）是衡量一个页面完成变成可交互状态的时间，当一个页面满足以下几个条件时可以认为该页面是完全可交互的：",-1)),e[5]||(e[5]=t("ul",null,[t("li",null,"从FCP指标后开始计算，保证已经有内容被渲染出来。"),t("li",null,"大多数的事件已经挂载在DOM上，完成注册。"),t("li",null,"此时主线程已经达到“流畅”的程度，主线程的任务均不超过 50 毫秒。")],-1)),a(n(l),{tips:[0,3.8,7.3],unit:"s"}),e[6]||(e[6]=t("h3",{id:"fid",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#fid"},[t("span",null,"FID")])],-1)),e[7]||(e[7]=t("p",null,"FID（First Input Delay）译为首次输入延迟。顾名思义，FID指的是用户首次与产品进行交互时，产品可以在多长时间给出反馈。",-1)),e[8]||(e[8]=t("blockquote",null,[t("p",null,"TTI可以告诉我们网页什么时候可以开始流畅地响应用户的交互，但是如果用户在TTI的时间内，没有与网页产生交互，那么TTI其实是影响不到用户的，TTI是不需要用户参与的指标，但如果我们真的想知道TTI对用户的影响，我们需要FID。不同的用户可能会在TTI之前开始与网页产生交互，也可能在TTI之后才与网页产生交互。所以对于不同的用户它的FID是不同的。如果在TTI之前用户就已经与网页产生了交互，那么它的FID时间就比较长，而如果在TTI之后才第一次与网页产生交互，那么他的FID时间就短。")],-1)),a(n(l),{tips:[0,100,300],unit:"ms"}),e[9]||(e[9]=t("h3",{id:"tbt",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#tbt"},[t("span",null,"TBT")])],-1)),e[10]||(e[10]=t("p",null,"阻塞总时间，TBT（Total Blocking Time）汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task中阻塞部分都会被汇总。",-1)),a(n(l),{tips:[0,200,600],unit:"ms"}),e[11]||(e[11]=t("h3",{id:"cls",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#cls"},[t("span",null,"CLS")])],-1)),e[12]||(e[12]=t("p",null,"累计位移偏量,CLS（Cumulative Layout Shift），记录了页面上非预期的位移波动。计算方式为：位移影响的面积 * 位移距离。",-1)),a(n(l),{tips:[0,.1,.25]}),e[13]||(e[13]=t("h2",{id:"如何获取指标",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#如何获取指标"},[t("span",null,"如何获取指标")])],-1)),e[14]||(e[14]=t("ul",null,[t("li",null,"Chrome DevTools - Lighthouse"),t("li",null,"Chrome DevTools - Performance"),t("li",null,"web-vitals 库")],-1))]))}}),C=JSON.parse('{"path":"/web/RAIL/","title":"RAIL模型","lang":"zh-CN","frontmatter":{"date":"2022-06-05T00:00:00.000Z","category":["web"],"tag":["performance"],"description":"RAIL模型 RAIL是一种以用户为中心的性能模型，将用户体验分解到按钮操作（比如：点击、滚动、加载）中，为每个操作定义性能目标 RAIL代表Web应用生命周期的四个不同方面：响应、动画、空闲、加载 响应(Response) 目标: 在100毫秒内完成由用户输入发起的转换，让用户感觉交互是即时的。 准则: 为了确保在 100 毫秒内产生可见响应，需要在...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RAIL模型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-05T00:00:00.000Z\\",\\"dateModified\\":\\"2022-07-06T08:44:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"utaware\\",\\"url\\":\\"https://github.com/utaware\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/utaware/web/RAIL/"}],["meta",{"property":"og:site_name","content":"utaware"}],["meta",{"property":"og:title","content":"RAIL模型"}],["meta",{"property":"og:description","content":"RAIL模型 RAIL是一种以用户为中心的性能模型，将用户体验分解到按钮操作（比如：点击、滚动、加载）中，为每个操作定义性能目标 RAIL代表Web应用生命周期的四个不同方面：响应、动画、空闲、加载 响应(Response) 目标: 在100毫秒内完成由用户输入发起的转换，让用户感觉交互是即时的。 准则: 为了确保在 100 毫秒内产生可见响应，需要在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-07-06T08:44:44.000Z"}],["meta",{"property":"article:tag","content":"performance"}],["meta",{"property":"article:published_time","content":"2022-06-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-07-06T08:44:44.000Z"}]]},"git":{"createdTime":1657097084000,"updatedTime":1657097084000,"contributors":[{"name":"utaware","username":"utaware","email":"1264051408@qq.com","commits":1,"url":"https://github.com/utaware"}]},"readingTime":{"minutes":6.69,"words":2006},"filePathRelative":"web/RAIL/README.md","excerpt":"","autoDesc":true}');export{P as comp,C as data};
