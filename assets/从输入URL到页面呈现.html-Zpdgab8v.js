import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as e,a}from"./app-qSMjXEym.js";const r={},n=a(`<h1 id="从输入-url-到页面呈现" tabindex="-1"><a class="header-anchor" href="#从输入-url-到页面呈现" aria-hidden="true">#</a> 从输入 URL 到页面呈现</h1><ul><li>URL</li><li>DNS <ul><li>CDN</li><li>DNS 缓存</li><li>DNS 均衡负载</li><li>DNS 预解析</li></ul></li><li>HTTP <ul><li>HTTP 请求方法</li><li>HTTP 请求状态码</li><li>HTTP 请求头信息</li><li>HTTP 请求跨域 <ul><li>jsonp</li><li>postMessage</li><li>cors</li><li>proxy</li><li>iframe <ul><li>domain</li><li>window.name</li><li>hash</li></ul></li></ul></li><li>HTTP 缓存 <ul><li>Memory Cache</li><li>Service Worker Cache <ul><li>PWA</li></ul></li><li>HTTP Cache <ul><li>强缓存</li><li>协商缓存</li></ul></li><li>Push Cache <ul><li>http2</li></ul></li></ul></li><li>HTTP Cookie <ul><li>跨域 <ul><li>withcredentials</li></ul></li><li>属性 <ul><li>Secure</li><li>HttpOnly</li><li>Domain</li><li>Path</li><li>Expires</li></ul></li></ul></li><li>HTTP 连接管理 <ul><li>短连接</li><li>长连接</li><li>websockets</li><li>域名分片</li><li>域名收敛</li></ul></li><li>HTTPS <ul><li>对称加密和非对称加密</li></ul></li></ul></li><li>TCP <ul><li>三次握手</li><li>四次握手</li><li>UDP</li></ul></li><li>服务器处理请求并返回 HTTP 报文 <ul><li>服务端渲染</li></ul></li><li>浏览器解析 <ul><li>图片 <ul><li>精灵图</li><li>SVG</li><li>图标字体</li><li>webp</li></ul></li><li>渲染 <ul><li>重绘和重排</li><li>优化指标</li><li>首屏优化 <ul><li>骨架屏</li><li>懒加载 <ul><li>滚动监听+scrollTop+offsetTop+innerHeight</li><li>滚动监听+getBoundingClientRect()</li><li>Intersection Observer</li></ul></li></ul></li></ul></li><li>存储 <ul><li>Cookie</li><li>Session Storage</li><li>Local Storage</li><li>IndexedDB</li></ul></li><li>JS 执行 <ul><li>Web-Worker</li><li>事件循环 <ul><li>宏任务、微任务</li><li>Promise</li><li>防抖和节流</li><li>async/await</li></ul></li></ul></li></ul></li></ul><h2 id="url" tabindex="-1"><a class="header-anchor" href="#url" aria-hidden="true">#</a> URL</h2><blockquote><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源</p></blockquote><p><code>scheme: // host.domain:port / path / filename ? abc = 123 # 456789</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，
               其中最常见的类型是 http，而 https 则是进行加密的网络传输。
<span class="token function">host</span>         - 定义域主机（http 的默认主机是 www）
domain       - 定义因特网域名，比如 baidu.com
port         - 定义主机上的端口号（http 的默认端口号是 <span class="token number">80</span>）
path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename     - 定义文档/资源的名称
query        - 即查询参数
fragment     - 即 <span class="token comment"># 后的hash值，一般用来定位到某个位置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</strong></p><h2 id="浏览器缓存" tabindex="-1"><a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a> 浏览器缓存</h2><p><strong>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</strong></p><h2 id="dns-解析" tabindex="-1"><a class="header-anchor" href="#dns-解析" aria-hidden="true">#</a> DNS 解析</h2><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。DNS（Domain Name System）的作用就是将主机名转换成 IP 地址。</p><blockquote><p>DNS 是一个应用层协议，将主机名转换成 IP 地址。同时，也是一个分布式数据库，整个 DNS 系统由分散在世界各地的很多台 DNS 服务器组成，每台 DNS 服务器上都保存了一些数据以获得最终的 IP。</p></blockquote><p><strong>DNS 查询</strong></p><p><code>本地 DNS 服务器</code>(TCP/IP 参数中设置的首选 DNS 服务器)</p><p><strong>DNS 缓存</strong></p><ol><li>浏览器缓存</li><li>OS 缓存</li><li>路由器缓存</li><li>访问 DNS 服务器(通常是 ISP)</li></ol><h3 id="递归查询-recursive-query" tabindex="-1"><a class="header-anchor" href="#递归查询-recursive-query" aria-hidden="true">#</a> 递归查询 (Recursive Query)</h3><p>客户端(发起) -&gt; 本地 DNS 服务器 | ISP -&gt; 客户端(收到)</p><p>服务器会代表客户端执行所有必要的进一步查询，直到它获得答案</p><h3 id="迭代查询-iterative-query" tabindex="-1"><a class="header-anchor" href="#迭代查询-iterative-query" aria-hidden="true">#</a> 迭代查询 (Iterative Query)</h3><p>本地 DNS 服务器</p><ol><li>根名称服务器(<code>.</code>)</li><li>顶级名称服务器(<code>com</code>)</li><li>二级名称服务器(<code>microsoft.com</code>)</li><li>权威名称服务器(<code>example.microsoft.com</code>)</li></ol><p><strong>DNS 负载均衡</strong></p><blockquote><p>(DNS 重定向) DNS 负载均衡技术的实现原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时， DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">提示</p><p>CDN(Content Delivery Network)就是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容。</p><blockquote><p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p></blockquote></div><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><ul><li>三次挥手</li><li>四次握手</li></ul><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><blockquote><p>HTTP 的端口为 80/8080，而 HTTPS 的端口为 443</p></blockquote><p>发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送到服务器指定端口，请求报文由请求行，请求报头，请求正文组成。</p><ul><li>HTTP 是无连接的</li></ul><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 一个连接是由传输层来控制的，这从根本上不属于 HTTP 的范围。HTTP 并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。</p><ul><li>HTTP 是可扩展的</li></ul><p>在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</p><ul><li>HTTP 是无状态</li></ul><p>HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 使用 Cookies 可以创建有状态的会话。</p><h2 id="browser" tabindex="-1"><a class="header-anchor" href="#browser" aria-hidden="true">#</a> Browser</h2><ul><li>用户界面(User Interface)</li><li>浏览器引擎(Browser Engine)</li><li>渲染引擎(Rendering Engine)</li><li>网络(Networking)</li><li>JS 解释器(JS Interpreter)</li><li>UI 后端(UI Backend)</li><li>数据存储(DB Persistence)</li></ul>`,38),t=[n];function o(s,u){return i(),e("div",null,t)}const h=l(r,[["render",o],["__file","从输入URL到页面呈现.html.vue"]]);export{h as default};
