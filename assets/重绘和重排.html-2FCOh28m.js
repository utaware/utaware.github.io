import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as i,a as l}from"./app-qSMjXEym.js";const o={},d=l('<h1 id="重绘和重排" tabindex="-1"><a class="header-anchor" href="#重绘和重排" aria-hidden="true">#</a> 重绘和重排</h1><h2 id="关键渲染路径" tabindex="-1"><a class="header-anchor" href="#关键渲染路径" aria-hidden="true">#</a> 关键渲染路径</h2><p>浏览器的关键渲染路径<code>CRP(Critical Rendering Path)</code>是指浏览器在加载和渲染网页时所经过的一系列关键步骤，以便将网页内容呈现给用户。</p><table><thead><tr><th>步骤</th><th>说明</th></tr></thead><tbody><tr><td>解析 HTML</td><td>解析服务器返回的 HTML 文档，构建 DOM 树。</td></tr><tr><td>解析 CSS</td><td>解析 CSS 样式表，构建 CSSOM 树。</td></tr><tr><td>合成渲染树</td><td>结合 DOM 树和 CSSOM 树生成渲染树，包括可见元素和样式布局信息。</td></tr><tr><td>布局计算</td><td>对渲染树进行布局计算，确定元素在屏幕上的位置和大小。</td></tr><tr><td>绘制</td><td>根据渲染树和布局计算的结果，将页面内容绘制到屏幕上。</td></tr><tr><td>栅格化</td><td>将绘制的内容拆分成小的图块，方便传输和显示。</td></tr><tr><td>合成</td><td>将栅格化后的图块组合成一帧画面，显示在屏幕上。</td></tr></tbody></table><p><strong>DOM 发生改变的时候触发重排，使 DOM 重新排列，重绘不一定会重排，但重排一定会发生重绘</strong></p><h2 id="重绘" tabindex="-1"><a class="header-anchor" href="#重绘" aria-hidden="true">#</a> 重绘</h2><blockquote><p>重绘就是重新绘制（repaint）：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p></blockquote><p><strong>外观属性包括界面、文字等可用状态向量描述的属性</strong></p><p>界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility</p><p>文字：text、font、word</p><h2 id="重排" tabindex="-1"><a class="header-anchor" href="#重排" aria-hidden="true">#</a> 重排</h2><blockquote><p>重排就是重新排列（reflow）：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p></blockquote><p><strong>改变元素几何信息（大小和位置）</strong></p><ul><li>添加或删除可见的 DOM 元素</li><li>元素位置改变，或者使用动画</li><li>元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）</li><li>内容改变（例如：文本改变或图片被另一个不同尺寸的图片替代、在 input 框输入内容）</li><li>浏览器窗口尺寸改变（resize 事件发生时）</li><li>页面渲染初始化</li><li>设置 style 属性的值</li><li>计算 offsetWidth、offsetHeight、offsetTop 和 offsetLeft 等布局信息</li><li>激活 CSS 伪类（如 :hover）</li><li>查询某些属性或调用某些方法（如：getComputedStyle()、getBoundingClientRect()）</li></ul><p><strong>几何属性包括布局、尺寸等可用数学几何衡量的属性</strong></p><p>布局：display、float、position、list、table、flex、columns、grid</p><p>尺寸：margin、padding、border、width、height</p><p><strong>获取布局信息的属性或方法</strong></p><blockquote><p>offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()、getBoundingClientRect()</p></blockquote><h2 id="减少影响" tabindex="-1"><a class="header-anchor" href="#减少影响" aria-hidden="true">#</a> 减少影响</h2><ul><li>避免一条一条的修改 DOM 的样式，可以直接修改 DOM 的 className</li><li>避免把 DOM 结点的属性值放在一个循环里当成循环里的变量</li><li>给动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 css 是不会重排</li><li>避免在大量元素上使用:hover</li><li>分离读写操作</li><li>避免使用 Table 布局</li><li>避免设置多层内联样式</li><li>避免在布局信息改变时查询布局信息</li><li>当需要对 DOM 元素进行一系列的操作时，可以先使元素脱离文档流，再对其进行一些列操作，然后再把元素带回文档中 <ul><li>隐藏元素，施加修改，重新显示</li><li>使用<code>document fragment</code>在当前 DOM 之外构建一个子树，再把它拷贝回文档</li><li>将元素元素拷贝到另一个脱离文档的节点中，修改副本，完成后再替换原始元素</li></ul></li></ul>',21),r=[d];function a(n,s){return e(),i("div",null,r)}const p=t(o,[["render",a],["__file","重绘和重排.html.vue"]]);export{p as default};
